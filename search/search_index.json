{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 A Python package for interacting with cTrader Open API. This package is developed and maintained by Spotware. You can use OpenApiPy on all kinds of Python apps, it uses Twisted to send and receive messages asynchronously. Github Repository: https://github.com/spotware/OpenApiPy Installation \u00b6 You can install OpenApiPy from pip: pip install ctrader-open-api Usage \u00b6 from ctrader_open_api import Client , Protobuf , TcpProtocol , Auth , EndPoints from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiMessages_pb2 import * from ctrader_open_api.messages.OpenApiModelMessages_pb2 import * from twisted.internet import reactor hostType = input ( \"Host (Live/Demo): \" ) host = EndPoints . PROTOBUF_LIVE_HOST if hostType . lower () == \"live\" else EndPoints . PROTOBUF_DEMO_HOST client = Client ( host , EndPoints . PROTOBUF_PORT , TcpProtocol ) def onError ( failure ): # Call back for errors print ( \"Message Error: \" , failure ) def connected ( client ): # Callback for client connection print ( \" \\n Connected\" ) # Now we send a ProtoOAApplicationAuthReq request = ProtoOAApplicationAuthReq () request . clientId = \"Your application Client ID\" request . clientSecret = \"Your application Client secret\" # Client send method returns a Twisted deferred deferred = client . send ( request ) # You can use the returned Twisted deferred to attach callbacks # for getting message response or error backs for getting error if something went wrong # deferred.addCallbacks(onProtoOAApplicationAuthRes, onError) deferred . addErrback ( onError ) def disconnected ( client , reason ): # Callback for client disconnection print ( \" \\n Disconnected: \" , reason ) def onMessageReceived ( client , message ): # Callback for receiving all messages print ( \"Message received: \\n \" , Protobuf . extract ( message )) # Setting optional client callbacks client . setConnectedCallback ( connected ) client . setDisconnectedCallback ( disconnected ) client . setMessageReceivedCallback ( onMessageReceived ) # Starting the client service client . startService () # Run Twisted reactor reactor . run ()","title":"Getting Started"},{"location":"#introduction","text":"A Python package for interacting with cTrader Open API. This package is developed and maintained by Spotware. You can use OpenApiPy on all kinds of Python apps, it uses Twisted to send and receive messages asynchronously. Github Repository: https://github.com/spotware/OpenApiPy","title":"Introduction"},{"location":"#installation","text":"You can install OpenApiPy from pip: pip install ctrader-open-api","title":"Installation"},{"location":"#usage","text":"from ctrader_open_api import Client , Protobuf , TcpProtocol , Auth , EndPoints from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiMessages_pb2 import * from ctrader_open_api.messages.OpenApiModelMessages_pb2 import * from twisted.internet import reactor hostType = input ( \"Host (Live/Demo): \" ) host = EndPoints . PROTOBUF_LIVE_HOST if hostType . lower () == \"live\" else EndPoints . PROTOBUF_DEMO_HOST client = Client ( host , EndPoints . PROTOBUF_PORT , TcpProtocol ) def onError ( failure ): # Call back for errors print ( \"Message Error: \" , failure ) def connected ( client ): # Callback for client connection print ( \" \\n Connected\" ) # Now we send a ProtoOAApplicationAuthReq request = ProtoOAApplicationAuthReq () request . clientId = \"Your application Client ID\" request . clientSecret = \"Your application Client secret\" # Client send method returns a Twisted deferred deferred = client . send ( request ) # You can use the returned Twisted deferred to attach callbacks # for getting message response or error backs for getting error if something went wrong # deferred.addCallbacks(onProtoOAApplicationAuthRes, onError) deferred . addErrback ( onError ) def disconnected ( client , reason ): # Callback for client disconnection print ( \" \\n Disconnected: \" , reason ) def onMessageReceived ( client , message ): # Callback for receiving all messages print ( \"Message received: \\n \" , Protobuf . extract ( message )) # Setting optional client callbacks client . setConnectedCallback ( connected ) client . setDisconnectedCallback ( disconnected ) client . setMessageReceivedCallback ( onMessageReceived ) # Starting the client service client . startService () # Run Twisted reactor reactor . run ()","title":"Usage"},{"location":"authentication/","text":"Auth Class \u00b6 For authentication you can use the package Auth class, first create an instance of it: from ctrader_open_api import Auth auth = Auth ( \"Your App ID\" , \"Your App Secret\" , \"Your App redirect URI\" ) Auth URI \u00b6 The first step for authentication is sending user to the cTrader Open API authentication web page, there the user will give access to your API application to manage the user trading accounts on behalf of him. To get the cTrader Open API authentication web page URL you can use the Auth class getAuthUri method: authUri = auth . getAuthUri () The getAuthUri has two optional parameters: scope: Allows you to set the scope of authentication, the default value is trading which means you will have full access to user trading accounts, if you want to just have access to user trading account data then use accounts baseUri: The base URI for authentication, the default value is EndPoints.AUTH_URI which is https://connect.spotware.com/apps/auth Getting Token \u00b6 After user authenticated your Application he will be redirected to your provided redirect URI with an authentication code appended at the end of your redirect URI: https://redirect-uri.com/?code={authorization-code-will-be-here} You can use this authentication code to get an access token from API, for that you can use the Auth class getToken method: # This method uses EndPoints.TOKEN_URI as a base URI to get token # you can change it by passing another URI via optional baseUri parameter token = auth . getToken ( \"auth_code\" ) Pass the received auth code to getToken method and it will give you a token JSON object, the object will have these properties: accessToken: This is the access token that you will use for authentication refreshToken: This is the token that you will use for refreshing the accessToken onces it expired expiresIn: The expiry of token in seconds from the time it generated tokenType: The type of token, standard OAuth token type parameter (bearer) errorCode: This will have the error code if something went wrong description: The error description Refreshing Token \u00b6 API access tokens have an expiry time, you can only use it until that time and once it expired you have to refresh it by using the refresh token you received previously. To refresh an access token you can use the Auth class refreshToken method: # This method uses EndPoints.TOKEN_URI as a base URI to refresh token # you can change it by passing another URI via optional baseUri parameter newToken = auth . refreshToken ( \"refresh_Token\" ) You have to pass the refresh token to \"refreshToken\" method, and it will return a new token JSON object which will have all the previously mentioned token properties. You can always refresh a token, even before it expires and the refresh token has no expiry, but you can only use it once.","title":"Authentication"},{"location":"authentication/#auth-class","text":"For authentication you can use the package Auth class, first create an instance of it: from ctrader_open_api import Auth auth = Auth ( \"Your App ID\" , \"Your App Secret\" , \"Your App redirect URI\" )","title":"Auth Class"},{"location":"authentication/#auth-uri","text":"The first step for authentication is sending user to the cTrader Open API authentication web page, there the user will give access to your API application to manage the user trading accounts on behalf of him. To get the cTrader Open API authentication web page URL you can use the Auth class getAuthUri method: authUri = auth . getAuthUri () The getAuthUri has two optional parameters: scope: Allows you to set the scope of authentication, the default value is trading which means you will have full access to user trading accounts, if you want to just have access to user trading account data then use accounts baseUri: The base URI for authentication, the default value is EndPoints.AUTH_URI which is https://connect.spotware.com/apps/auth","title":"Auth URI"},{"location":"authentication/#getting-token","text":"After user authenticated your Application he will be redirected to your provided redirect URI with an authentication code appended at the end of your redirect URI: https://redirect-uri.com/?code={authorization-code-will-be-here} You can use this authentication code to get an access token from API, for that you can use the Auth class getToken method: # This method uses EndPoints.TOKEN_URI as a base URI to get token # you can change it by passing another URI via optional baseUri parameter token = auth . getToken ( \"auth_code\" ) Pass the received auth code to getToken method and it will give you a token JSON object, the object will have these properties: accessToken: This is the access token that you will use for authentication refreshToken: This is the token that you will use for refreshing the accessToken onces it expired expiresIn: The expiry of token in seconds from the time it generated tokenType: The type of token, standard OAuth token type parameter (bearer) errorCode: This will have the error code if something went wrong description: The error description","title":"Getting Token"},{"location":"authentication/#refreshing-token","text":"API access tokens have an expiry time, you can only use it until that time and once it expired you have to refresh it by using the refresh token you received previously. To refresh an access token you can use the Auth class refreshToken method: # This method uses EndPoints.TOKEN_URI as a base URI to refresh token # you can change it by passing another URI via optional baseUri parameter newToken = auth . refreshToken ( \"refresh_Token\" ) You have to pass the refresh token to \"refreshToken\" method, and it will return a new token JSON object which will have all the previously mentioned token properties. You can always refresh a token, even before it expires and the refresh token has no expiry, but you can only use it once.","title":"Refreshing Token"},{"location":"client/","text":"Client Class \u00b6 You will use an instance of this class to interact with API. Each instance of this class will have one connection to API, either live or demo endpoint. The client class is driven from Twisted ClientService class, and it abstracts away all the connection / reconnection complexities from you. Creating a Client \u00b6 Let's create an isntance of Client class: from ctrader_open_api import Client , Protobuf , TcpProtocol , Auth , EndPoints client = Client ( EndPoints . PROTOBUF_DEMO_HOST , EndPoints . PROTOBUF_PORT , TcpProtocol ) It's constructor has several parameters that you can use for controling it behavior: host: The API host endpoint, you can use either EndPoints.PROTOBUF_DEMO_HOST or EndPoints.PROTOBUF_LIVE_HOST port: The API host port number, you can use EndPoints.PROTOBUF_PORT protocol: The protocol that will be used by client for making connections, use imported TcpProtocol numberOfMessagesToSendPerSecond: This is the number of messages that will be sent to API per second, set it based on API limitations or leave the default value There are three other optional parameters which are from Twisted client service, you can find their detail here: https://twistedmatrix.com/documents/current/api/twisted.application.internet.ClientService.html Sending Message \u00b6 To send a message you have to first create the proto message, ex: # Import all message types from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiMessages_pb2 import * from ctrader_open_api.messages.OpenApiModelMessages_pb2 import * # ProtoOAApplicationAuthReq message applicationAuthReq = ProtoOAApplicationAuthReq () applicationAuthReq . clientId = \"Your App Client ID\" applicationAuthReq . clientSecret = \"Your App Client secret\" After you created the message and populated its fields, you can send it by using Client send method: deferred = client . send ( applicationAuthReq ) The client send method returns a Twisted deferred, it will be called when the message response arrived, the callback result will be the response proto message. If the message send failed, the returned deferred error callback will be called, to handle both cases you can attach two callbacks for getting response or error: def onProtoOAApplicationAuthRes ( result ): print ( result ) def onError ( failure ): print ( failure ) deferred . addCallbacks ( onProtoOAApplicationAuthRes , onError ) For more about Twisted deferreds please check their documentation: https://docs.twistedmatrix.com/en/twisted-16.2.0/core/howto/defer-intro.html Canceling Message \u00b6 You can cancel a message by calling the returned deferred from Client send method Cancel method. If the message is not sent yet, it will be removed from the messages queue and the deferred Errback method will be called with CancelledError. If the message is already sent but the response is not received yet, then you will not receive the response and the deferred Errback method will be called with CancelledError. If the message is already sent and the reponse is received then canceling it's deferred will not have any effect. Other Callbacks \u00b6 The client class has some other optional general purpose callbacks that you can use: ConnectedCallback(client): This callback will be called when client gets connected, use client setConnectedCallback method to assign a callback for it DisconnectedCallback(client, reason): This callback will be called when client gets disconnected, use client setDisconnectedCallback method to assign a callback for it MessageReceivedCallback(client, message): This callback will be called when a message is received, it's called for all message types, use setMessageReceivedCallback to assign a callback for it","title":"Client"},{"location":"client/#client-class","text":"You will use an instance of this class to interact with API. Each instance of this class will have one connection to API, either live or demo endpoint. The client class is driven from Twisted ClientService class, and it abstracts away all the connection / reconnection complexities from you.","title":"Client Class"},{"location":"client/#creating-a-client","text":"Let's create an isntance of Client class: from ctrader_open_api import Client , Protobuf , TcpProtocol , Auth , EndPoints client = Client ( EndPoints . PROTOBUF_DEMO_HOST , EndPoints . PROTOBUF_PORT , TcpProtocol ) It's constructor has several parameters that you can use for controling it behavior: host: The API host endpoint, you can use either EndPoints.PROTOBUF_DEMO_HOST or EndPoints.PROTOBUF_LIVE_HOST port: The API host port number, you can use EndPoints.PROTOBUF_PORT protocol: The protocol that will be used by client for making connections, use imported TcpProtocol numberOfMessagesToSendPerSecond: This is the number of messages that will be sent to API per second, set it based on API limitations or leave the default value There are three other optional parameters which are from Twisted client service, you can find their detail here: https://twistedmatrix.com/documents/current/api/twisted.application.internet.ClientService.html","title":"Creating a Client"},{"location":"client/#sending-message","text":"To send a message you have to first create the proto message, ex: # Import all message types from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiCommonMessages_pb2 import * from ctrader_open_api.messages.OpenApiMessages_pb2 import * from ctrader_open_api.messages.OpenApiModelMessages_pb2 import * # ProtoOAApplicationAuthReq message applicationAuthReq = ProtoOAApplicationAuthReq () applicationAuthReq . clientId = \"Your App Client ID\" applicationAuthReq . clientSecret = \"Your App Client secret\" After you created the message and populated its fields, you can send it by using Client send method: deferred = client . send ( applicationAuthReq ) The client send method returns a Twisted deferred, it will be called when the message response arrived, the callback result will be the response proto message. If the message send failed, the returned deferred error callback will be called, to handle both cases you can attach two callbacks for getting response or error: def onProtoOAApplicationAuthRes ( result ): print ( result ) def onError ( failure ): print ( failure ) deferred . addCallbacks ( onProtoOAApplicationAuthRes , onError ) For more about Twisted deferreds please check their documentation: https://docs.twistedmatrix.com/en/twisted-16.2.0/core/howto/defer-intro.html","title":"Sending Message"},{"location":"client/#canceling-message","text":"You can cancel a message by calling the returned deferred from Client send method Cancel method. If the message is not sent yet, it will be removed from the messages queue and the deferred Errback method will be called with CancelledError. If the message is already sent but the response is not received yet, then you will not receive the response and the deferred Errback method will be called with CancelledError. If the message is already sent and the reponse is received then canceling it's deferred will not have any effect.","title":"Canceling Message"},{"location":"client/#other-callbacks","text":"The client class has some other optional general purpose callbacks that you can use: ConnectedCallback(client): This callback will be called when client gets connected, use client setConnectedCallback method to assign a callback for it DisconnectedCallback(client, reason): This callback will be called when client gets disconnected, use client setDisconnectedCallback method to assign a callback for it MessageReceivedCallback(client, message): This callback will be called when a message is received, it's called for all message types, use setMessageReceivedCallback to assign a callback for it","title":"Other Callbacks"}]}